# Cloud Datastoreとクエリ

## クエリ

さて、こうした保存したデータはFirebase APIを利用して読み込むことが出来ます。この読み込む際にAPIに対して投げるリクエストのことを専門用語ではクエリと呼びます。

Cloud Datastoreは、以下のようにファンクションを組み合わせていくことでクエリを投げます。

```js
const db = firebase.firestore();

const quizzesSnapshot = db.collection("quizes").get(); 
```

上記のクエリで返ってくるのはPromiseオブジェクトです。例えば、指定したコレクションが存在しない場合はrejectされてerrorが返ってきます。取得に成功した場合は、`QuerySnapshot`というオブジェクトがresolveさえて返ってきます。

なぜ、直接リストでドキュメントを返してこないのでしょうか？ これはなぜかというと、Cloud Datastoreはデータの変更がリアルタイムに変更されることを想定しており、データが変更された際にコールバックファンクションを呼び出すような利用方法も想定しているからです。

`QuerySnapshot`オブジェクトは`forEach`というファンクションが定義されています。これを利用することで戻ってきたコレクションのドキュメントにアクセスすることが出来ます。

```js
quizzesSnapshot.forEach((doc) => {
  console.log(doc.id); // クイズドキュメントのIDの取得
  console.log(doc.data()); // クイズドキュメントのデータの取得
})
```

また、ドキュメント一覧は次のようにして取得することも出来ます。

```js
const quizzes = quizzesSnapshot.docs
```

今回、作成するアプリではどちらの方法も利用していきます。サブコレクションを取得するためのクエリの作成方法などはアプリを作りながら説明していきます。

## ドキュメントとクエリ

上記のサブコレクションとマップに関する説明の部分で、メニュー一覧やレビュー一覧はサブコレクションに入れるべきと説明しました。これはCloud Firestoreではドキュメントに対してクエリを利用して一部だけを取ってくるということが出来ないからです。

そのため、仮にマップを利用してレビューやメニュー一覧を保存した場合、どんな場合でも全てのレビューと全てのメニューがレストラン情報と一緒に読み込まれます。

このことが引き起こす問題はデータ量の問題です。例えばレストラン一覧のページがあった場合、レビューやメニューを表示するとしてもせいぜい1個あるいは数個のはずです。

それにも関わらず、マップを利用すると全てのレストランのレビューデータも取ってくることになります。レビューは時間が経つに連れて増えるので大変な量のデータになってしまうことが想像出来るかと思います。

大量のデータを読み込むのには時間がかかり、またそのデータを扱うためのメモリ消費量も大きくなるため、アプリ全体の動きが遅くなりユーザビリティが大きく落ちてしまいます。

このように、全てのデータを取得する必要がなく、またデータ量が大きくなりそうな場合はサブコレクションを利用するのが賢明です。